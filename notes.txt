1. After review 2, we tested wtih 200 votes, we got a result of 197 votes being written to the blockchain
    batch id which were not written were -> 116, 117, 154

2. To solve the above issue, here is a solution
    Use Redis as a shared in-memory store/dictionary.
    On the bc side, every batch which comes in, take its batch id and add it to redis.
    When the intersection is calculated by the orderer, and a random orderer sends it back to the bc node,
        the bc node iterates over the intersection batch and deletes all the batch ids in the intersection batch from the redis dictionary.
    In regular intervals, say 10 minutes, a process interacts with redis to send those unregistered votes back to the database instance.
    The database instance stores a mapping of the batch id and the voter id.
    An update is called on the database instance where the record with the voterid and batchid is deleted and the isAlreadyVoted flag is set to False.
        Also the voter will receive a notification that his vote was not registered and he/she will be asked to vote again.

            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] - initially written to redis by bc node

            [1, 2, 3, 7, 8, 9, 10] - intersection batch from orderer to bc and to the peers

            the intersection batch is broadcasted to the peer orderers where they remove the batches
                from the unique_votes dictionary which are not present in the intersection batch

            1, 2, 3, 7, 8, 9, 10 - written to csv on the bc nodes

            at timeout which runs on the bc nodes, redis is scanned by a random bc node for the batches and they are put back in the loop of being considered again as a normal batch would

            4, 5, 6 - to be sent by the bc to the orderer

3. Probably make a flowchart for the algorithms

4. automation of deploy.py from another central instance which will also serve the purpose of generating clusterid

------------------------------------------------------------------------------------------------------------------------------------------------

{ level_num:int, clusterid:int, batchid:int, cand1:int, cand2:int, cand3:int }
       0                0            db         1           0          0

------------------------------------------------------------------------------------------------------------------------------------------------

New sorting logic to be implemented in the intersect_votes() when we are just about to broadcast the batch

level   cluster_id   batch_id
( 1,         1,         1 )
( 1,         2,         2 )
( 1,         2,         1 )
( 1,         1,         2 )

First, sort by level_no. All have level 1, so this step is trivial.
Then sort each level by cluster_id (here, we have only 1 level).

Cluster_id subset 1:
( 1,         1,         1 )
( 1,         1,         2 )
And subset 2:
( 1,         2,         2 )
( 1,         2,         1 )

Finally, we sort each cluster_id subset by batch_id.

Cluster_id subset 1:
( 1,         1,         1 )
( 1,         1,         2 )
And subset 2:
( 1,         2,         1 )
( 1,         2,         2 )

Also writing to blockchain code has to be modified to take the cluster_id into account

------------------------------------------------------------------------------------------------------------------------------------------------
